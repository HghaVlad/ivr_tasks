## STEP 1

<p><strong>Настройки файла settings.py</strong></p>

<p> </p>

<p>В данном уроке мы изучим:</p>

<ul>
	<li>Какие файлы создаются при создании проекта </li>
	<li>Основные методы файла settings.py </li>
	<li>Как создать логгирование проекта</li>
</ul>

# STEP 2

<p><strong>Файлы проекта</strong></p>

<p>Когда мы создаем проект, то в директории появляется папка и некоторые файлы проекта.</p>

<p>Файлы, которые содержатся в папке проекта:</p>

<ul>
	<li>__init__.py</li>
	<li>asgi.py</li>
	<li>settings.py</li>
	<li>urls.py</li>
	<li>wsgi.py</li>
</ul>

<p>Данные файлы необходимо для настройка самого проекта. Само содержание находится в приложениях. Каждое приложение состоит из python пакета, который представляет некоторый набор функций. Приложениями удобно пользоваться при масштабирования проекта. Мы можем скопировать приложения из одного проекта в другой.<br>
Приложения включают в себя некоторую комбинацию моделей, представлений, шаблонов, тегов шаблонов, статических файлов, URL-адресов, промежуточного программного обеспечения и т. д. Они обычно связаны с проектами с INSTALLED_APPS настройкой и, необязательно, с другими механизмами, например URLconfs.</p>

<p>Файл __init__.py обязательный в каждом пакете python. По умолчанию он пустой, но при его отсутствии проект не будет считаться пакетом. <br>
Для размещения проекта на сервере необходимы файлы wsgi.py или asgi.py. Поддержка ASGI появилась с 3 версии django, данный стандарт позволяет взаимодействовать с проектом в асинхронном режиме.<br>
Настройки всего проекта находятся в файле settings.py именно ему посвящен данный урок.<br>
Urls.py - это то, что в платформе Django известно как URLconf, конфигурационный файл, который отображает шаблоны адресов URL на действия, выполняемые приложением.</p>

<p><strong>Архитектура Django</strong></p>

<p style="text-align: center;"><img alt="" height="800" name="image.png" src="https://ucarecdn.com/41545875-4deb-43a6-92ff-914a91c27464/" width="518"></p>

<p>Схема выше отображает картину взаимодействия пользователя с сервером. <br>
Поступающие от пользователя HTTP запросы передаются Django, который принимает их на промежуточном уровне обработки запросов(Middleware). После этого происходит анализ URL, благодаря которому запросы отправляются к нужным представлениям. Представления выполняют основную часть работу, иногда вызывают модели. После сформирования ответа, с использованием шаблонов отправляется ответ пользователю. </p>

## STEP 3

<p>Какой файл появился относительно недавно в Django?</p>

- settings.py
- views.py
- urls.py
- wsgi.py
- asgi.py ✅

## STEP 4

<p><strong>Настройки проекта</strong></p>

<p>Файл настроек Django содержит всю конфигурацию вашей установки Django</p>

<p>Если вы откроете файл settings.py, то вы уже увидите некоторое количество кода. В данном шаге мы рассмотрим подробно что выполняет каждый кусок кода. В следующих шагах мы ознакомимся с другими возможностями данного модуля.</p>

<p>В данном файле содержится множество комментариев, поэтому многое интуитивно понятно. Мы прокомментируем функционал файла, созданного автоматически используя Django версии 4.1.7</p>

<pre><code>from pathlib import Path
BASE_DIR = Path(__file__).resolve().parent.parent</code></pre>

<p>Первое, что выполняет программа это получает абсолютный путь проекта. В дальнейшем это потребуется для некоторых настроек.</p>

<pre><code>SECRET_KEY = 'django-insecure-qf5!=no7=fr_#^v_a9x$jz=f))4#&amp;+x(2joguf3_t#q)z(y5h)'</code></pre>

<p>Переменная, необходимая для шифрования. Он должен быть уникальным в каждом проекте и не распространяться. Храните его в безопасном месте.</p>

<pre><code>DEBUG = True
ALLOWED_HOSTS = []</code></pre>

<p>DEBUG - когда включен данный параметр, на сайте отображаются ошибки. Не забудьте изменить значение, когда используете проект в продакшене.<br>
ALLOWED_HOSTS - в данном списке записываются хосты с которых доступен сайт. Если запустить сайт под доменном, то пользователь не сможет к нему подключиться. Так как пока что вы используете проект локально, то данная переменная вам не нужна. Подробнее вы узнаете в уроке, посвященному деплою проекта.</p>

<pre><code>INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]</code></pre>

<p>Каждое приложение необходимо подключать в файле. По умолчанию Django подключает некоторые встроенные приложения, когда вам требуется добавить ваше приложение(<em>manage.py startapp &lt;&gt;</em>) добавьте в список новую строку.</p>

<pre><code>INSTALLED_APPS = [
    'django.contrib.admin',
    ...
    'django.contrib.staticfiles',
    'mainapp',
]</code></pre>

<pre><code>MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]</code>
</pre>

<p>Middleware - это система хуков для обработки запросов/ответов в Django. Это легкая, низкоуровневая система «плагинов» для глобального изменения входных или выходных данных Django; промежуточный слой между запросом и ответом.<br>
С точки зрения пользователя <em>Middleware - </em>это словно мост, связывающий между собой две части программы или системы. <br>
Подробнее про middleware вы узнаете позже.<br>
 </p>

<pre><code>TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]</code></pre>

<p>За конфигурацию шаблонов в проекте отвечает переменная TEMPLATES. Данная переменная принимает список конфигураций.</p>

<ul>
	<li>BACKEND - движок шаблонов, по умолчанию встроенный тип</li>
	<li>DIRS - список каталогов, где движок будет искать файлы шаблонов</li>
	<li>APP_DIRS - указывает, будет ли движок шаблонов искать шаблоны внутри папок приложений в папке templates</li>
	<li>OPTIONS - определяет дополнительный список параметров. В частности, указывает, какие обработчики будут использоваться при обработке шаблонов.</li>
</ul>

<p>Подробнее про шаблоны вы узнаете в следующей главе.</p>

<pre><code>ROOT_URLCONF = 'maincourse.urls'
WSGI_APPLICATION = 'maincourse.wsgi.application'</code></pre>

<p><span style="color: #000000;">Путь к файлу urls и wsgi. </span></p>

<pre><code>DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}</code></pre>

<p>База данный, привязанная к проекту. По умолчанию стоит sqlite3 база. Про сами базы данных, зачем они нужны и  как их подключить вы узнаете в отдельной главе.</p>

<pre><code>AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]</code></pre>

<p>AUTH_PASSWORD_VALIDATORS  - Список валидаторов паролей пользователя. Они определяют на сколько сложный пароль пользователя. </p>

<pre><code>LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True</code></pre>

<p>Переменный описывающие язык, время и перевод</p>

<ul>
	<li><em>LANGUAGE_CODE </em>-  язык проекта</li>
	<li><em>TIME_ZONE </em>- часовой пояс</li>
	<li><em>USE_I18N </em>- Включена ли встроенная система перевода. Для производительности рекомендуется поставить False</li>
	<li><em>USE_TZ </em>- Зависит ли datetimes от часового пояса</li>
</ul>

<pre><code>STATIC_URL = 'static/'
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'</code></pre>

<p>STATIC_URL - путь к папке со статическими файлами. Подробнее про файлы вы узнаете в следующих главах<br>
AUTO_FIELD - размер переменной Primery key, используется при работе с базой и моделями.</p>

## STEP 5

<p><strong>Использование настроек в коде Python</strong></p>

<p>В<strong> </strong>самих приложениях можно использовать модуль, а именно его переменные.</p>

<pre><code>from django.conf import settings
if settings.DEBUG:
    print("IT is debuging")</code></pre>

<p>Изменять настройки во время выполнения нельзя.<br>
Данный код не будет работать исправно:</p>

<pre><code>settings.DEBUG = False</code></pre>

<p><strong>Создание собственных настроек</strong></p>

<p>Вы также можете использовать файл настроек как config файл своего проекта. Это позволяет вам добавлять собственные переменные и позже обращаться к ним. Но следуйте этим рекомендациям:</p>

<ul>
	<li>Имена настроек должны быть полностью прописными</li>
	<li>Не изобретайте заново уже существующий сеттинг.</li>
</ul>

<p>Для настроек, являющихся последовательностями, сам Django использует списки, но это всего лишь соглашение.</p>

## STEP 6

<p>Как необходимо добавлять созданные вами приложения в django?</p>

- В список INSTALLED_APPS ✅
- Импортировать `__init__.py` файл
- Приложения никак не импортируются
- Никак, приложения автоматически добавляются

## STEP 7

<p><strong>Логи</strong></p>

<p>Очень часто для откладки программисты используют print(), но есть более "элегантный" и гибкий способ откладки это логирование. </p>

<p>Django использует встроенный в Python модуль logging.</p>

<p>Изначально нам требуется настроить логирование. Это делается в файле settings.py</p>

<pre><code>LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'debug_file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': '&lt;path_to_file&gt;/debug.log'
        },
        'error_file': {
            'level': 'ERROR',
            'class': 'logging.FileHandler',
            'filename': '&lt;path_to_file&gt;/error.log'
        }
    },
    'loggers': {
            'django': {
                'handlers': ['debug_file'],
                'level': 'DEBUG',
                'propagate': True,
            },
            '': {
                'handlers': ['error_file'],
                'level': 'ERROR',
                'propagate': True,
            },
        },
}</code></pre>

<p>Мы добавили новую переменную LOGGING, которая содержит настройки логов. <em>version</em> - это версия наших логов, в данном случае 1.<br>
Переменная <em>disable_existing_loggers </em>указывает, что уже существующие логгеры не должны быть отключены. Если бы это было True, то Django отключил бы все существующие логгеры перед созданием новых логгеров.<br>
После чего мы определяем <em>handlers(обработчики) </em>они определяют, каким образом записываются логируемые сообщения в файлы, базы данных, электронную почту, консоль и т.д. Обработчик определяет, куда отправлять сообщения, которые были обработаны логгером. </p>

<p>Существует несколько типов обработчиков, которые можно использовать в приложениях:</p>

<ul>
	<li>
	<p><code>StreamHandler</code>: записывает сообщения в поток (как правило, в <code>sys.stdout</code> или <code>sys.stderr</code>), который может быть направлен на консоль или в другое место.</p>
	</li>
	<li>
	<p><code>FileHandler</code>: записывает сообщения в файл. Обычно используется для создания лог-файлов.</p>
	</li>
	<li>
	<p><code>RotatingFileHandler</code>: записывает сообщения в файл, но при достижении определенного размера, создает новый файл и продолжает записывать сообщения в него. Это позволяет контролировать размер лог-файлов.</p>
	</li>
	<li>
	<p><code>TimedRotatingFileHandler</code>: записывает сообщения в файл и создает новый файл в заданные интервалы времени (например, каждый день, каждую неделю).</p>
	</li>
	<li>
	<p><code>SMTPHandler</code>: отправляет сообщения по электронной почте.</p>
	</li>
	<li>
	<p><code>MemoryHandler</code>: буферизует сообщения в памяти и отправляет их на другой обработчик при достижении определенного порога.</p>
	</li>
</ul>

<p>Дальше мы добавили настройки для логгеров(<em>loggers</em>). Существует множество логгеров, вот основные:</p>

<ul>
	<li>
	<p><code>root logger</code>: это главный логгер, который создается автоматически при загрузке модуля <code>logging</code>. Он используется по умолчанию для всех сообщений, если не задано другое имя логгера.</p>
	</li>
	<li>
	<p><code>__name__ logger</code>: каждый модуль в Python имеет свой собственный логгер, который может быть создан с использованием имени модуля. Имя логгера соответствует имени модуля, в котором он был создан.</p>
	</li>
	<li>
	<p><code>Third-party loggers</code>: многие сторонние библиотеки имеют свои собственные логгеры, которые можно использовать для логирования сообщений, связанных с работой этих библиотек.</p>
	</li>
	<li>
	<p><code>Custom loggers</code>: разработчики могут создавать свои собственные логгеры с помощью класса <code>Logger</code>, чтобы логировать сообщения, связанные с различными компонентами приложения.</p>
	</li>
</ul>

<p>В нашем случае мы добавили логгер модуля <em>django</em> и <em>root logger</em>.</p>

<p> </p>

<p>Модуль logging в Python предоставляет несколько уровней логирования(<em>level</em>), которые могут быть использованы для фильтрации сообщений в обработчиках. Уровень логирования устанавливается для каждого обработчика, и сообщения, уровень которых ниже заданного уровня, не будут записываться в журнал. Некоторые из уровней логирования включают в себя:</p>

<ol>
	<li>
	<p><code>CRITICAL</code>: самый высокий уровень логирования, используется для сообщений, которые указывают на критические ошибки, которые могут привести к непредсказуемым результатам.</p>
	</li>
	<li>
	<p><code>ERROR</code>: используется для сообщений об ошибках, которые могут привести к прерыванию работы приложения или привести к нежелательным результатам.</p>
	</li>
	<li>
	<p><code>WARNING</code>: используется для сообщений о предупреждениях, которые указывают на возможные проблемы или ошибки, но которые не приведут к критическим проблемам.</p>
	</li>
	<li>
	<p><code>INFO</code>: используется для сообщений, которые содержат информацию о работе приложения или о состоянии системы.</p>
	</li>
	<li>
	<p><code>DEBUG</code>: самый низкий уровень логирования, используется для сообщений, которые помогают отладить работу приложения или понять причину возникновения ошибок.</p>
	</li>
	<li>
	<p><code>NOTSET</code>: используется, чтобы указать, что уровень логирования не установлен явно. Если уровень логирования не установлен для обработчика, он будет использовать значение <code>NOTSET</code>.</p>
	</li>
</ol>

<p>Обычно для логгера устанавливаются уровни <code>INFO</code> или <code>DEBUG</code>, в зависимости от того, насколько подробную информацию необходимо логировать. Для каждого обработчика можно установить свой уровень логирования, чтобы записывать только нужную информацию в журнал.</p>

## STEP 8

<p>Какая переменная в модуле settings должна быть уникальной?</p>

- ALLOWED_HOSTS
- SECRET_KEY ✅
- LOGGERS
- TEMPLATES
- LOGGING
